# ClickHouse

## 一、简介

### 1.1 概况

* ClickHouse是一个用于联机分析(OLAP)的列式数据库管理系统(DBMS)。

#### 1.1.1 行式数据库

* 处于同一行中的数据总是被物理的存储在一起。
* 常见的行式数据库：MySQL、Postgres和MS SQL Server。

| Row  | name     | title | event |
| ---- | -------- | ----- | ----- |
| #0   | zhangsan | day1  | swim  |
| #1   | lisi     | day2  | sleep |
| #2   | wangwu   | day3  | eat   |
| #N   | ....     | ...   | ....  |

查询：

![row_oriented](ClickHouse.assets/row_oriented.gif)

#### 1.1.2 列式数据库

* 列式数据库总是将同一列的数据存储在一起，不同列的数据也总是分开存储。
* 常见的列式数据库有： Vertica、 Paraccel (Actian Matrix，Amazon Redshift)、 Sybase IQ、 Exasol、 Infobright、 InfiniDB、 MonetDB (VectorWise， Actian Vector)、 LucidDB、 SAP HANA、 Google Dremel、 Google PowerDrill、 Druid、 kdb+。

| Row   | #0       | #1    | #2     | #N   |
| ----- | -------- | ----- | ------ | ---- |
| name  | zhangsan | lisi  | wangwu | ...  |
| title | day1     | day2  | day3   | ...  |
| event | swim     | sleep | eat    | ...  |

查询：

![column_oriented](ClickHouse.assets/column_oriented.gif)

#### 1.1.3 数据库对比

* Input/Output
  * 针对分析类查询，通常只需要读取表的一小部分列。在列式数据库中你可以只读取你需要的数据。例如，如果只需要读取100列中的5列，这将帮助你最少减少20倍的I/O消耗。
  * 由于数据总是打包成批量读取的，所以压缩是非常容易的。同时数据按列分别存储这也更容易压缩。这进一步降低了I/O的体积。
  * 由于I/O的降低，这将帮助更多的数据被系统缓存。
  * 例如，查询“统计每个广告平台的记录数量”需要读取“广告平台ID”这一列，它在未压缩的情况下需要1个字节进行存储。如果大部分流量不是来自广告平台，那么这一列至少可以以十倍的压缩率被压缩。当采用快速压缩算法，它的解压速度最少在十亿字节(未压缩数据)每秒。换句话说，这个查询可以在单个服务器上以每秒大约几十亿行的速度进行处理。这实际上是当前实现的速度。
* CPU
  * 由于执行一个查询需要处理大量的行，因此在整个向量上执行所有操作将比在每一行上执行所有操作更加高效。同时这将有助于实现一个几乎没有调用成本的查询引擎。如果你不这样做，使用任何一个机械硬盘，查询引擎都不可避免的停止CPU进行等待。所以，在数据按列存储并且按列执行是很有意义的。
  * 有两种方法可以做到这一点：
    1. 向量引擎：所有的操作都是为向量而不是为单个值编写的。这意味着多个操作之间的不再需要频繁的调用，并且调用的成本基本可以忽略不计。操作代码包含一个优化的内部循环。
    2. 代码生成：生成一段代码，包含查询中的所有操作。
  * 这是不应该在一个通用数据库中实现的，因为这在运行简单查询时是没有意义的。但是也有例外，例如，MemSQL使用代码生成来减少处理SQL查询的延迟(只是为了比较，分析型数据库通常需要优化的是吞吐而不是延迟)。

#### 1.1.4 场景与数据库选择

* 进行了哪些查询，多久查询一次以及各类查询的比例；
* 每种查询读取多少数据————行、列和字节；
* 读取数据和写入数据之间的关系；
* 使用的数据集大小以及如何使用本地的数据集；
* 是否使用事务,以及它们是如何进行隔离的；
* 数据的复制机制与数据的完整性要求；
* 每种类型的查询要求的延迟与吞吐量等等。

#### 1.1.5 OLAP场景

* 大多数是读请求
* 数据总是以相当大的批(> 1000 rows)进行写入
* 不修改已添加的数据
* 每次查询都从数据库中读取大量的行，但是同时又仅需要少量的列
* 宽表，即每个表包含着大量的列
* 较少的查询(通常每台服务器每秒数百个查询或更少)
* 对于简单查询，允许延迟大约50毫秒
* 列中的数据相对较小： 数字和短字符串(例如，每个URL 60个字节)
* 处理单个查询时需要高吞吐量（每个服务器每秒高达数十亿行）
* 事务不是必须的
* 对数据一致性要求低
* 每一个查询除了一个大表外都很小
* 查询结果明显小于源数据，换句话说，数据被过滤或聚合后能够被盛放在单台服务器的内存中

|          | OLTP                                               | OLAP                                               |
| -------- | -------------------------------------------------- | -------------------------------------------------- |
| 全称     | 联机事务处理<br />on-line transaction processing   | 联机分析处理<br />on-line analytical processing    |
| 用户     | 操作人员                                           | 决策人员                                           |
| DB设计   | 面向应用                                           | 面向决策                                           |
| 数据     | 当前的、最新的<br />细节的<br />二维的<br />分立的 | 历史的<br />聚集的<br />多维的<br />集成的、统一的 |
| 存取     | 读/写多条记录                                      | 读上百万条记录                                     |
| 工作单位 | 简单的事务                                         | 复杂的查询                                         |
| DB大小   | 100MB-GB                                           | 100GB-TB                                           |
| 时间要求 | 实时性                                             | 对时间要求不高                                     |
| 主要应用 | 数据库                                             | 数据仓库                                           |

### 1.2 ClickHouse 特性

#### 1.2.1 真正的历史数据库管理系统

* 在一个真正的列式数据库管理系统中，除了数据本身外不应该存在其他额外的数据。这意味着为了避免在值旁边存储它们的长度“number”，你必须支持固定长度数值类型。
* 例如，10亿个UInt8类型的数据在未压缩的情况下大约消耗1GB左右的空间，如果不是这样的话，这将对CPU的使用产生强烈影响。即使是在未压缩的情况下，紧凑的存储数据也是非常重要的，因为解压缩的速度主要取决于未压缩数据的大小。

#### 1.2.2 数据压缩

* 在一些列式数据库管理系统中(例如：InfiniDB CE 和 MonetDB) 并没有使用数据压缩。但是, 若想达到比较优异的性能，数据压缩确实起到了至关重要的作用。

#### 1.2.3 数据的磁盘管理

* 许多的列式数据库(如 SAP HANA, Google PowerDrill)只能在内存中工作，这种方式会造成比实际更多的设备预算。
* ClickHouse被设计用于工作在传统磁盘上的系统，它提供每GB更低的存储成本，但如果有可以使用SSD和内存，它也会合理的利用这些资源。

#### 1.2.4 多核心并行处理

ClickHouse会使用服务器上一切可用的资源，从而以最自然的方式并行处理大型查询。

#### 1.2.5 多服务器分布式处理

上面提到的列式数据库管理系统中，几乎没有一个支持分布式的查询处理。 在ClickHouse中，数据可以保存在不同的shard上，每一个shard都由一组用于容错的replica组成，查询可以并行地在所有shard上进行处理。这些对用户来说是透明的

#### 1.2.6 支持SQL

ClickHouse支持基于SQL的声明式查询语言，该语言大部分情况下是与SQL标准兼容的。 支持的查询包括 GROUP BY，ORDER BY，IN，JOIN以及非相关子查询。 不支持窗口函数和相关子查询。

#### 1.2.7 向量引擎

为了高效的使用CPU，数据不仅仅按列存储，同时还按向量(列的一部分)进行处理，这样可以更加高效地使用CPU。

#### 1.2.8 实时的数据更新

ClickHouse支持在表中定义主键。为了使查询能够快速在主键中进行范围查找，数据总是以增量的方式有序的存储在MergeTree中。因此，数据可以持续不断地高效的写入到表中，并且写入的过程中不会存在任何加锁的行为。

#### 1.2.9 索引

按照主键对数据进行排序，这将帮助ClickHouse在几十毫秒以内完成对数据特定值或范围的查找。

#### 1.2.10 适合在线查询

在线查询意味着在没有对数据做任何预处理的情况下以极低的延迟处理查询并将结果加载到用户的页面中。

#### 1.2.11 支持近似计算

* ClickHouse提供各种各样在允许牺牲数据精度的情况下对查询进行加速的方法：
  1. 用于近似计算的各类聚合函数，如：distinct values, medians, quantiles
  2. 基于数据的部分样本进行近似查询。这时，仅会从磁盘检索少部分比例的数据。
  3. 不使用全部的聚合条件，通过随机选择有限个数据聚合条件进行聚合。这在数据聚合条件满足某些分布条件下，在提供相当准确的聚合结果的同时降低了计算资源的使用。

#### 1.2.12 支持数据复制和数据完整性

* ClickHouse使用异步的多主复制技术。当数据被写入任何一个可用副本后，系统会在后台将数据分发给其他副本，以保证系统在不同副本上保持相同的数据。在大多数情况下ClickHouse能在故障后自动恢复，在一些少数的复杂情况下需要手动恢复。

### 1.3 缺点

1. 没有完整的事务支持。
2. 缺少高频率，低延迟的修改或删除已存在数据的能力。仅能用于批量删除或修改数据，但这符合 [GDPR](https://gdpr-info.eu/)（通用数据保护条例）。
3. 稀疏索引使得ClickHouse不适合通过其键检索单行的点查询。

### 1.4 性能

* 根据Yandex的内部测试结果，ClickHouse表现出了比同类可比较产品更优的性能。你可以在 [这里](https://clickhouse.yandex/benchmark.html) 查看具体的测试结果。

#### 1.4.1 单个大查询的吞吐量

* 吞吐量可以使用每秒处理的行数或每秒处理的字节数来衡量。
* 如果数据被放置在page cache中，则一个不太复杂的查询在单个服务器上大约能够以2-10GB／s（未压缩）的速度进行处理（对于简单的查询，速度可以达到30GB／s）。如果数据没有在page cache中的话，那么速度将取决于你的磁盘系统和数据的压缩率。
* 如果一个磁盘允许以400MB／s的速度读取数据，并且数据压缩率是3，则数据的处理速度为1.2GB/s。这意味着，如果你是在提取一个10字节的列，那么它的处理速度大约是1-2亿行每秒。
* 对于分布式处理，处理速度几乎是线性扩展的，但这受限于聚合或排序的结果不是那么大的情况下。

#### 1.4.2 处理短查询的延迟时间

* 如果一个查询使用主键并且没有太多行(几十万)进行处理，并且没有查询太多的列，那么在数据被page cache缓存的情况下，它的延迟应该小于50毫秒(在最佳的情况下应该小于10毫秒)。 否则，延迟取决于数据的查找次数。
* 如果你当前使用的是HDD，在数据没有加载的情况下，查询所需要的延迟可以通过以下公式计算得知： 查找时间（10 ms） * 查询的列的数量 * 查询的数据块的数量。

#### 1.4.3 处理大量短查询的吞吐量

* 在相同的情况下，ClickHouse可以在单个服务器上每秒处理数百个查询（在最佳的情况下最多可以处理数千个）。
* 但是由于这不适用于分析型场景。因此我们建议每秒最多查询100次。

#### 1.4.4 数据的写入性能

* 我们建议每次写入不少于1000行的批量写入，或每秒不超过一个写入请求。
* 当使用tab-separated格式将一份数据写入到MergeTree表中时，写入速度大约为50到200MB/s。
* 如果您写入的数据每行为1Kb，那么写入的速度为50，000到200，000行每秒。如果您的行更小，那么写入速度将更高。
* 为了提高写入性能，您可以使用多个INSERT进行并行写入，这将带来线性的性能提升。

### 1.5 历史

* ClickHouse最初是为 [Yandex.Metrica](https://metrica.yandex.com/) [世界第二大Web分析平台](http://w3techs.com/technologies/overview/traffic_analysis/all) 而开发的。多年来一直作为该系统的核心组件被该系统持续使用着。目前为止，该系统在ClickHouse中有超过13万亿条记录，并且每天超过200多亿个事件被处理。它允许直接从原始数据中动态查询并生成报告。本文简要介绍了ClickHouse在其早期发展阶段的目标。
* Yandex.Metrica基于用户定义的字段，对实时访问、连接会话，生成实时的统计报表。这种需求往往需要复杂聚合方式，比如对访问用户进行去重。构建报表的数据，是实时接收存储的新数据。
* 截至2014年4月，Yandex.Metrica每天跟踪大约120亿个事件（用户的点击和浏览）。为了可以创建自定义的报表，我们必须存储全部这些事件。同时，这些查询可能需要在几百毫秒内扫描数百万行的数据，或在几秒内扫描数亿行的数据。

#### 1.5.1 聚合数据与非聚合数据

* 有一种流行的观点认为，想要有效的计算统计数据，必须要聚合数据，因为聚合将降低数据量。
* 但是数据聚合是一个有诸多限制的解决方案，例如：
  - 你必须提前知道用户定义的报表的字段列表
  - 用户无法自定义报表
  - 当聚合条件过多时，可能不会减少数据，聚合是无用的。
  - 存在大量报表时，有太多的聚合变化（组合爆炸）
  - 当聚合条件有非常大的基数时（如：url），数据量没有太大减少（少于两倍）
  - 聚合的数据量可能会增长而不是收缩
  - 用户不会查看我们为他生成的所有报告，大部分计算将是无用的
  - 各种聚合可能违背了数据的逻辑完整性
* 如果我们直接使用非聚合数据而不进行任何聚合时，我们的计算量可能是减少的。
* 然而，相对于聚合中很大一部分工作被离线完成，在线计算需要尽快的完成计算，因为用户在等待结果。