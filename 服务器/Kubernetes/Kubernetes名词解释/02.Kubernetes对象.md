# Kubernetes概念

## Kubernetes对象

* Kubernetes对象是Kubernetes系统中的持久实体。Kubernetes使用这些实体来表示集群的状态。
  * **容器化应用正在运行(以及在哪些节点上)**
  * **这些应用可用的资源**
  * **关于这些应用如何运行的策略，如重新策略，升级和容错**
* 必填字段
  * **apiVersion - 创建对象的Kubernetes API 版本**
  * **kind - 要创建什么样的对象？**
  * **metadata- 具有唯一标示对象的数据，包括 name（字符串）、UID和Namespace（可选项）**

## 一、Names

* Kubernetes REST API中的所有对象都用Name和UID来明确地标识。

## 二、Namespaces

* Namespace为名称提供了一个范围。资源的Names在Namespace中具有唯一性。
* Namespace是一种将集群资源划分为多个用途的方法。

Namespaces管理：

```sh
#### 创建Namespaces
#(1) 命令行直接创建
$ kubectl create namespace new-namespace

#(2) 通过文件创建
$ cat my-namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: new-namespace
# 创建
$ kubectl create -f ./my-namespace.yaml

### 删除Namespaces
$ kubectl delete namespaces new-namespace

### 查看namespaces
$ kubectl get namespaces
NAME          STATUS    AGE
default       Active    1d
kube-system   Active    1d

### 根据Namespaces进行查询

$ kubectl get pods --namespaces=kube-system
```

* 都在某些Namespace中。
  * 大多数Kubernetes资源（例如pod、services、replication controllers或其他）
* 不在Namespace中。
  * 但Namespace资源本身并
  * 低级别资源（如Node不在任何Namespace中。
* Events是一个例外：它们可能有也可能没有Namespace，具体取决于Events的对象。

### 2.1 配置Pod配额（ResourceQuota）

==**设置Pod配额以限制可以在名字空间中运行的Pod数量**==

**创建命名空间**

```sh
kubectl create namespace quota-pod-example
```

**创建ResourceQuota对象**

```sh
# quota-pod.yaml
# kubectl create -f quota-pod.yaml --namespace=quota-pod-example
apiVersion: v1
kind: ResourceQuota
metadata:
  name: pod-demo
spec:
  hard:
    pods: "2"
```

**查看**

```sh
kubectl get resourcequota pod-demo --namespace=quota-pod-example --output=yaml
# 输出
spec:
  hard:
    pods: "2"
status:
  hard:
    pods: "2"
  used:
    pods: "0"
```


**创建Deployment**

```sh
# quota-pod-deployment.yaml
# kubectl create -f quota-pod-deployment.yaml --namespace=quota-pod-example

apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: pod-quota-demo
spec:
  replicas: 3
  template:
    metadata:
      labels:
        purpose: quota-demo
    spec:
      containers:
      - name: pod-quota-demo
        image: nginx
```

这个时候，如果创建以的Deployment，需要3个replicas，这个时间由于Pod的配额限制，只能创建两个Pod了。

### 2.2 配置默认的CPU请求与限额（LimitRange）

==**如果在一个拥有默认CPU限额的命名空间中创建一个容器，则这个容器不需要指定它自己的CPU限额， 它会被分配这个默认的CPU限额值**==

**创建一个命名空间**

```sh
kubectl create namespace default-cpu-example
```

**创建这个LimitRange**

现在如果在这个defaule-cpu-example命名空间中创建一个容器，则该容器不需要指定它自己的CPU请求和CPU限额， 该容器会被赋予一个默认的CPU请求值0.5和一个默认的CPU限额值1

```sh
# cpu-defaults.yaml
# kubectl create -f cpu-defaults.yaml --namespace=default-cpu-example

apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-limit-range
spec:
  limits:
    # CPU限额
  - default:
      cpu: 1
    # 默认的CPU请求
    defaultRequest:
      cpu: 0.5
    type: Container
```

**创建Pod**

```sh
# cpu-defaults-pod.yaml
# kubectl create -f cpu-defaults-pod.yaml --namespace=default-cpu-example

apiVersion: v1
kind: Pod
metadata:
  name: default-cpu-demo
spec:
  containers:
  - name: default-cpu-demo-ctr
    image: nginx
```

**查看**

```sh
# kubectl get pod default-cpu-demo --output=yaml --namespace=default-cpu-example
containers:
- image: nginx
  imagePullPolicy: Always
  name: default-cpu-demo-ctr
  resources:
    # 限额
    limits:
      cpu: "1"
    # 请求
    requests:
      cpu: 500m
```

**默认CPU限额和请求的动机**

如果你的命名空间含有资源配额, 它是有帮助的对于设置一个CPU限额的默认值。 以下是资源配额对命名空间施加的两个限制：

* **在命名空间运行的每一个容器必须含有它自己的CPU限额。**
* **在命名空间中所有容器使用的CPU总量不能超出指定的限额。**

如果一个容器没有指定它自己的CPU限额，它将被赋予默认的限额值，然后它可以在被配额限制的命名空间中运行。

### 2.3 配置默认的内存请求与限额（LimitRange）

==** 如果在一个拥有默认内存限额的命名空间中创建一个容器，并且这个容器未指定它自己的内存限额， 它会被分配这个默认的内存限额值。**==

**创建命名空间**

```
kubectl create namespace default-mem-example
```

**创建 LimitRange** 

```sh
# memory-defaults.yaml
# kubectl create -f memory-defaults.yaml --namespace=default-mem-example

apiVersion: v1
kind: LimitRange
metadata:
  name: mem-limit-range
spec:
  limits:
  - default:
      memory: 512Mi
    defaultRequest:
      memory: 256Mi
    type: Container
```

**创建Pod**

```sh
# memory-defaults-pod.yaml
# kubectl create -f memory-defaults-pod.yaml --namespace=default-mem-example

apiVersion: v1
kind: Pod
metadata:
  name: default-mem-demo
spec:
  containers:
  - name: default-mem-demo-ctr
    image: nginx
```

**查看**

```sh
# kubectl get pod default-mem-demo --output=yaml --namespace=default-mem-example
containers:
- image: nginx
  imagePullPolicy: Always
  name: default-mem-demo-ctr
  resources:
    limits:
      memory: 512Mi
    requests:
      memory: 256Mi
```

**默认内存限额与请求的动机**

如果您的命名空间具有资源配额, 它为内存限额设置默认值是有意义的。 以下是资源配额对命名空间施加的两个限制：

- **在命名空间运行的每一个容器必须有它自己的内存限额。**
- **在命名空间中所有的容器使用的内存总量不能超出指定的限额。**

如果一个容器没有指定它自己的内存限额，它将被赋予默认的限额值，然后它才可以在被配额限制的命名空间中运行。

### 2.4  设置最小和最大内存限制（limitRange）

==**设置 LimitRange 对象中内存的最小和最大值。如果 Pod 没有符合 LimitRange 施加的限制，那么它就不能在 namespace 中创建**==

**创建一个 namespace**

```
kubectl create namespace constraints-mem-example
```

创建limitRange

```sh
# memory-constraints.yaml
# kubectl create -f https://k8s.io/docs/tasks/administer-cluster/memory-constraints.yaml --namespace=constraints-mem-example

apiVersion: v1
kind: LimitRange
metadata:
  name: mem-min-max-demo-lr
spec:
  limits:
  - max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container
```

**创建Pod**

```sh
# memory-constraints-pod.yaml
# kubectl create -f memory-constraints-pod.yaml --namespace=constraints-mem-example

apiVersion: v1
kind: Pod
metadata:
  name: constraints-mem-demo
spec:
  containers:
  - name: constraints-mem-demo-ctr
    image: nginx
    resources:
      limits:
        memory: "800Mi"
      requests:
        memory: "600Mi"
```

查看

```sh
# kubectl get pod constraints-mem-demo --output=yaml --namespace=constraints-mem-example

resources:
  limits:
     memory: 800Mi
  requests:
    memory: 600Mi
```

**应用最小和最大内存限制**

LimitRange 在 namespace 中施加的最小和最大内存限制只有在创建和更新 Pod 时才会被应用。改变 LimitRange 不会对之前创建的 Pod 造成影响。

**最小和最大内存限制的动因**

- 集群中每个节点拥有 2 GB 内存。您不希望任何 Pod 请求超过 2 GB 的内存，因为集群中没有节点能支持这个请求。
- 集群被生产部门和开发部门共享。 您希望生产负载最多使用 8 GB 的内存而将开发负载限制为 512 MB。这种情况下，您可以为生产环境和开发环境创建单独的 namespace，并对每个 namespace 应用内存限制。

### 2.5  配置CPU和内存配额

